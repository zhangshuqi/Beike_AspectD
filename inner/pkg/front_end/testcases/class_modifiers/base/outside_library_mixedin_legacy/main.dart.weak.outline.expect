library;
//
// Problems in library:
//
// pkg/front_end/testcases/class_modifiers/base/outside_library_mixedin_legacy/main.dart:13:7: Error: The type 'WithBaseMixinClass' must be 'base', 'final' or 'sealed' because the supertype 'BaseMixinClass' is 'base'.
// Try adding 'base', 'final', or 'sealed' to the type.
// class WithBaseMixinClass with BaseMixinClass {}
//       ^
//
// pkg/front_end/testcases/class_modifiers/base/outside_library_mixedin_legacy/main.dart:15:7: Error: The type 'WithAbstractBaseMixinClass' must be 'base', 'final' or 'sealed' because the supertype 'AbstractBaseMixinClass' is 'base'.
// Try adding 'base', 'final', or 'sealed' to the type.
// class WithAbstractBaseMixinClass with AbstractBaseMixinClass {}
//       ^
//
// pkg/front_end/testcases/class_modifiers/base/outside_library_mixedin_legacy/main.dart:17:7: Error: The type 'WithBaseMixin' must be 'base', 'final' or 'sealed' because the supertype 'BaseMixin' is 'base'.
// Try adding 'base', 'final', or 'sealed' to the type.
// class WithBaseMixin with BaseMixin {}
//       ^
//
// pkg/front_end/testcases/class_modifiers/base/outside_library_mixedin_legacy/main.dart:19:16: Error: The type 'AbstractWithBaseMixinClass' must be 'base', 'final' or 'sealed' because the supertype 'BaseMixinClass' is 'base'.
// Try adding 'base', 'final', or 'sealed' to the type.
// abstract class AbstractWithBaseMixinClass with BaseMixinClass {}
//                ^
//
// pkg/front_end/testcases/class_modifiers/base/outside_library_mixedin_legacy/main.dart:21:16: Error: The type 'AbstractWithAbstractBaseMixinClass' must be 'base', 'final' or 'sealed' because the supertype 'AbstractBaseMixinClass' is 'base'.
// Try adding 'base', 'final', or 'sealed' to the type.
// abstract class AbstractWithAbstractBaseMixinClass with AbstractBaseMixinClass {}
//                ^
//
// pkg/front_end/testcases/class_modifiers/base/outside_library_mixedin_legacy/main.dart:23:16: Error: The type 'AbstractWithBaseMixin' must be 'base', 'final' or 'sealed' because the supertype 'BaseMixin' is 'base'.
// Try adding 'base', 'final', or 'sealed' to the type.
// abstract class AbstractWithBaseMixin with BaseMixin {}
//                ^
//
import self as self;
import "dart:core" as core;
import "main_lib.dart" as mai;

import "org-dartlang-testcase:///main_lib.dart";

abstract final class _WithBaseMixinClass&Object&BaseMixinClass = core::Object with mai::BaseMixinClass /*isAnonymousMixin,hasConstConstructor*/  {
  const synthetic constructor •() → self::_WithBaseMixinClass&Object&BaseMixinClass
    : super core::Object::•()
    ;
}
class WithBaseMixinClass extends self::_WithBaseMixinClass&Object&BaseMixinClass {
  synthetic constructor •() → self::WithBaseMixinClass
    ;
}
abstract final class _WithAbstractBaseMixinClass&Object&AbstractBaseMixinClass = core::Object with mai::AbstractBaseMixinClass /*isAnonymousMixin,hasConstConstructor*/  {
  const synthetic constructor •() → self::_WithAbstractBaseMixinClass&Object&AbstractBaseMixinClass
    : super core::Object::•()
    ;
}
class WithAbstractBaseMixinClass extends self::_WithAbstractBaseMixinClass&Object&AbstractBaseMixinClass {
  synthetic constructor •() → self::WithAbstractBaseMixinClass
    ;
}
abstract final class _WithBaseMixin&Object&BaseMixin = core::Object with mai::BaseMixin /*isAnonymousMixin,hasConstConstructor*/  {
  const synthetic constructor •() → self::_WithBaseMixin&Object&BaseMixin
    : super core::Object::•()
    ;
}
class WithBaseMixin extends self::_WithBaseMixin&Object&BaseMixin {
  synthetic constructor •() → self::WithBaseMixin
    ;
}
abstract final class _AbstractWithBaseMixinClass&Object&BaseMixinClass = core::Object with mai::BaseMixinClass /*isAnonymousMixin,hasConstConstructor*/  {
  const synthetic constructor •() → self::_AbstractWithBaseMixinClass&Object&BaseMixinClass
    : super core::Object::•()
    ;
}
abstract class AbstractWithBaseMixinClass extends self::_AbstractWithBaseMixinClass&Object&BaseMixinClass {
  synthetic constructor •() → self::AbstractWithBaseMixinClass
    ;
}
abstract final class _AbstractWithAbstractBaseMixinClass&Object&AbstractBaseMixinClass = core::Object with mai::AbstractBaseMixinClass /*isAnonymousMixin,hasConstConstructor*/  {
  const synthetic constructor •() → self::_AbstractWithAbstractBaseMixinClass&Object&AbstractBaseMixinClass
    : super core::Object::•()
    ;
}
abstract class AbstractWithAbstractBaseMixinClass extends self::_AbstractWithAbstractBaseMixinClass&Object&AbstractBaseMixinClass {
  synthetic constructor •() → self::AbstractWithAbstractBaseMixinClass
    ;
}
abstract final class _AbstractWithBaseMixin&Object&BaseMixin = core::Object with mai::BaseMixin /*isAnonymousMixin,hasConstConstructor*/  {
  const synthetic constructor •() → self::_AbstractWithBaseMixin&Object&BaseMixin
    : super core::Object::•()
    ;
}
abstract class AbstractWithBaseMixin extends self::_AbstractWithBaseMixin&Object&BaseMixin {
  synthetic constructor •() → self::AbstractWithBaseMixin
    ;
}

library;
import self as mai;
import "dart:core" as core;

base mixin class BaseMixinClass extends core::Object {
  synthetic constructor •() → mai::BaseMixinClass
    ;
}
abstract base mixin class AbstractBaseMixinClass extends core::Object {
  synthetic constructor •() → mai::AbstractBaseMixinClass
    ;
}
abstract base class BaseMixin extends core::Object /*isMixinDeclaration*/  {
}
